--[[
    破砕A.anm
    Copyright (C) 2021 …FGH_JKL… / Ainashi

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
]]

@領域内ランダム拡散
--track0:進行度,0,100,10,0.01
--track1:拡散距離,0,300,30,0.01
--dialog:X方向偏り（px）,v_x=0;Y方向偏り（px）,v_y=0;X軸拡散倍率,r_x=1.0;Y軸拡散倍率,r_y=1.0;シード,seed=0;分割数,separate=4;余剰部分,surplus=1;

local progress = obj.track0
local length = obj.track1
seed = math.abs(math.floor(seed))
separate = math.min(math.max(1, math.floor(separate)),16)
r_x = math.max(0, r_x)
r_y = math.max(0, r_y)
local left = -obj.w / 2
local right = obj.w / 2
local top = -obj.h / 2
local bottom = obj.h / 2
local l = 2 ^ separate
local src = {
    ox = obj.ox,
    oy = obj.oy,
    oz = obj.oz,
    cx = obj.cx,
    cy = obj.cy,
    cz = obj.cz,
    rx = obj.rx,
    ry = obj.ry,
    rz = obj.rz,
    alpha = obj.alpha,
    zoom = obj.zoom
}
local clipping_arg = {}

if (progress ~= 0 and src.alpha ~= 0 and src.zoom ~= 0) then
    
    -- 一時バッファへコピー
    obj.copybuffer("tmp", "obj")
    
    -- 値の初期化
    for i = 1, separate do

        -- 乱数生成
        local cx = obj.rand(left, right, i, seed * 10 + 1)
        local cy = obj.rand(top, bottom, i, seed * 10 + 2)
        local deg = math.floor(obj.rand(1, 180, i, seed * 10 + 3))
        
        -- 生成結果を基に関数情報を設定
        local add_i = #clipping_arg + 1
        local slope = 0
        local intercept = 0
        local non_disp = 0
        local continue = 1

        if (deg ~= 90) then
            slope = math.tan(math.pi * deg / 180)
            intercept = cy - (slope * cx)
        end

        if (add_i ~= 1) then
            for j = 1, add_i - 1 do
                if ((deg ~= 90 and clipping_arg[j].slope == slope and clipping_arg[j].intercept == intercept) or 
                    (deg == 90 and clipping_arg[j].cx == cx)) then
                    continue = 0
                end
            end
        end

        if (continue == 1) then
                
            -- 境界がオブジェクト内部を通過しない可能性を検証
            if (slope > 90) then
                if (slope * (left + cx) + cy < top) then
                    non_disp = -1
                elseif (slope * (right + cx) + cy > bottom) then
                    non_disp = 1
                end
            elseif (slope < 90) then
                if (slope * (right + cx) + cy < top) then
                    non_disp = 1
                elseif (slope * (left + cx) + cy > bottom) then
                    non_disp = -1
                end
            else
                if (cx < left) then
                    non_disp = -1
                elseif (cx > right) then
                    non_disp = 1
                end
            end

            -- 値を格納
            clipping_arg[add_i] = {}
            clipping_arg[add_i].cx = cx
            clipping_arg[add_i].cy = cy
            clipping_arg[add_i].deg = deg
            clipping_arg[add_i].slope = slope
            clipping_arg[add_i].intercept = intercept
            clipping_arg[add_i].non_disp = non_disp
            clipping_arg[add_i].left = {}
            clipping_arg[add_i].right = {}
            clipping_arg[add_i].inner_top = {}
            clipping_arg[add_i].inner_bottom = {}
            clipping_arg[add_i].outer_top = {}
            clipping_arg[add_i].outer_bottom = {}
        end
    end

    separate = #clipping_arg    
    l = 2 ^ separate

    -- 値の位置関係を検討
    for i = 1, separate do
        for j = i, separate do
            if (i ~= j) then
                -- 二本の境界が平行かどうかを検証する
                if (clipping_arg[i].deg == clipping_arg[j].deg) then
                    -- 平行である場合
                    -- 切片を用いて検討する
                    if (clipping_arg[i].deg == 90) then
                        if (clipping_arg[i].cx < clipping_arg[j].cx) then
                            table.insert(clipping_arg[i].right, j)
                        else
                            table.insert(clipping_arg[i].left, j)
                        end
                    elseif (clipping_arg[i].intercept > clipping_arg[j].intercept) then
                        table.insert(clipping_arg[i].right, j)
                    else
                        table.insert(clipping_arg[i].left, j)
                    end
                else
                    -- 平行ではない場合
                    -- 交点を求めて検討する
                    local pt = {}
                    if (clipping_arg[i].deg == 90) then
                        pt.x = clipping_arg[i].cx
                        pt.y = clipping_arg[j].slope * pt.x + clipping_arg[j].intercept
                    elseif (clipping_arg[j].deg == 90) then
                        pt.x = clipping_arg[j].cx
                        pt.y = clipping_arg[i].slope * pt.x + clipping_arg[i].intercept
                    else
                        pt.x = (clipping_arg[i].intercept - clipping_arg[j].intercept) / (clipping_arg[j].slope - clipping_arg[i].slope)
                        pt.y = clipping_arg[i].slope * pt.x + clipping_arg[i].intercept
                    end

                    -- オブジェクト外部に交点がある場合を検討する
                    if (pt.y < top) then
                        -- 上側にある場合
                        if (clipping_arg[i].deg < clipping_arg[j].deg) then
                            table.insert(clipping_arg[i].left, j)
                        else
                            table.insert(clipping_arg[i].right, j)
                        end
                    elseif (pt.y > bottom) then
                        -- 下側にある場合
                        if (clipping_arg[i].deg < clipping_arg[j].deg) then
                            table.insert(clipping_arg[i].right, j)
                        else
                            table.insert(clipping_arg[i].left, j)
                        end
                    elseif (pt.x < left) then
                        -- 左側にある場合
                        if (math.max(clipping_arg[i].deg, clipping_arg[j].deg) < 90) then
                            -- 上側と同じ挙動
                            if (clipping_arg[i].deg < clipping_arg[j].deg) then
                                table.insert(clipping_arg[i].left, j)
                            else
                                table.insert(clipping_arg[i].right, j)
                            end
                        elseif (math.min(clipping_arg[i].deg, clipping_arg[j].deg) > 90) then
                            -- 下側と同じ挙動
                            if (clipping_arg[i].deg < clipping_arg[j].deg) then
                                table.insert(clipping_arg[i].right, j)
                            else
                                table.insert(clipping_arg[i].left, j)
                            end
                        else
                            -- 左側固有の挙動
                            if (clipping_arg[i].deg < clipping_arg[j].deg) then
                                table.insert(clipping_arg[i].outer_top, j)
                            else
                                table.insert(clipping_arg[i].outer_bottom, j)
                            end
                        end
                    elseif (pt.x > right) then
                        -- 右側にある場合
                        if (math.min(clipping_arg[i].deg, clipping_arg[j].deg) > 90) then
                            -- 上側と同じ挙動
                            if (clipping_arg[i].deg < clipping_arg[j].deg) then
                                table.insert(clipping_arg[i].left, j)
                            else
                                table.insert(clipping_arg[i].right, j)
                            end
                        elseif (math.max(clipping_arg[i].deg, clipping_arg[j].deg) < 90) then
                            -- 下側と同じ挙動
                            if (clipping_arg[i].deg < clipping_arg[j].deg) then
                                table.insert(clipping_arg[i].right, j)
                            else
                                table.insert(clipping_arg[i].left, j)
                            end
                        else
                            if (clipping_arg[i].deg < clipping_arg[j].deg) then
                                table.insert(clipping_arg[i].inner_bottom, j)
                            else
                                table.insert(clipping_arg[i].inner_top, j)
                            end
                        end
                    end
                end
            end
        end
    end

    -- 描画
    for i = 0, l - 1 do
        local continue = 1
        local reverse = {}
        local clip = {}

        -- 変数の初期化
        for j = 1, separate do
            reverse[j] = (((i % (2 ^ j)) >= (2 ^ (j - 1))) and 1 or 0)
            clip[j] = 1
        end

        for j = 1, separate do
            if (continue == 1 and clip[j]) then
                if (reverse[j] == 0) then
                    -- 反転しない場合
                    for idx, lefter in pairs(clipping_arg[j].left) do
                        -- 左側に別の境界がある場合
                        if (reverse[lefter] == 0) then
                            clip[lefter] = 0
                        else
                            continue = 0
                        end
                    end
                    for idx, righter in pairs(clipping_arg[j].right) do
                        -- 右側に別の境界がある場合
                        if (reverse[righter] == 0) then
                            clip[j] = 0
                        end
                    end
                    for idx, inner_top in pairs(clipping_arg[j].inner_top) do
                        -- 内部方向の上側に別の境界がある場合
                        if (reverse[inner_top] == 0) then
                            continue = 0
                        else
                            clip[inner_top] = 0
                        end
                    end
                    for idx, inner_bottom in pairs(clipping_arg[j].inner_bottom) do
                        -- 内部方向の下側に別の境界がある場合
                        if (reverse[inner_bottom] == 0) then
                            continue = 0
                        else
                            clip[inner_bottom] = 0
                        end
                    end
                    for idx, outer_top in pairs(clipping_arg[j].outer_top) do
                        -- 外部方向の上側に別の境界がある場合
                        if (reverse[outer_top] == 1) then
                            clip[j] = 0
                        end
                    end
                    for idx, outer_bottom in pairs(clipping_arg[j].outer_bottom) do
                        -- 外部方向の下側に別の境界がある場合
                        if (reverse[outer_bottom] == 1) then
                            clip[j] = 0
                        end
                    end
                else
                    -- 反転する場合
                    for idx, lefter in pairs(clipping_arg[j].left) do
                        -- 左側に別の境界が存在する場合
                        if (reverse[lefter] == 1) then
                            clip[j] = 0
                        end
                    end
                    for idx, righter in pairs(clipping_arg[j].right) do
                        -- 右側に別の境界がある場合
                        if (reverse[righter] == 0) then
                            continue = 0
                        else
                            clip[righter] = 0
                        end
                    end
                    for idx, inner_top in pairs(clipping_arg[j].inner_top) do
                        -- 内部方向の上側に別の境界がある場合
                        if (reverse[inner_top] == 0) then
                            clip[j] = 0
                        end
                    end
                    for idx, inner_bottom in pairs(clipping_arg[j].inner_bottom) do
                        -- 内部方向の下側に別の境界がある場合
                        if (reverse[inner_bottom] == 0) then
                            clip[j] = 0
                        end
                    end
                    for idx, outer_top in pairs(clipping_arg[j].outer_top) do
                        -- 外部方向の上側に別の境界がある場合
                        if (reverse[outer_top] == 0) then
                            clip[outer_top] = 0
                        else
                            continue = 0
                        end
                    end
                    for idx, outer_bottom in pairs(clipping_arg[j].outer_bottom) do
                        -- 外部方向の下側に別の境界がある場合
                        if (reverse[outer_bottom] == 0) then
                            clip[outer_bottom] = 0
                        else
                            continue = 0
                        end
                    end
                end
            end
        end

        if (continue == 1) then
            obj.load("tempbuffer")

            -- 斜めクリッピング
            for j = 1, separate do
                if (clip[j] == 1) then
                    local cx = clipping_arg[j].cx
                    local cy = clipping_arg[j].cy
                    local deg = clipping_arg[j].deg
                    if (reverse[j] == 1) then
                        deg = deg + 180
                    end
                    cx = cx - math.sin(math.pi * deg / 180) * surplus
                    cy = cy + math.cos(math.pi * deg / 180) * surplus
                    obj.effect(
                        "斜めクリッピング",
                        "中心X", cx,
                        "中心Y", cy,
                        "角度", deg,
                        "ぼかし", 0)
                end
            end

            obj.ox = src.ox
            obj.oy = src.oy
            obj.oz = src.oz
            obj.cx = src.cx
            obj.cy = src.cy
            obj.cz = src.cz
            obj.rx = src.rx
            obj.ry = src.ry
            obj.rz = src.rz
            obj.alpha = src.alpha
            obj.zoom = src.zoom
            obj.effect()

            local mov_deg = obj.rand(1, 360, i, seed * 10 + 4)
            local x = length * math.cos(math.pi * mov_deg / 180) * r_x + v_x
            local y = length * math.sin(math.pi * mov_deg / 180) * r_y + v_y
            local rate = progress / 100
            obj.draw(x * rate, y * rate)
        end
    end
end


@クリップ座標位置指定
--track0:進行度,0,100,10,0.01
--track1:拡散距離,0,300,30,0.01
--track2:X座標,-1000,1000,0,1
--track3:Y座標,-1000,1000,0,1
--dialog:X方向偏り（px）,v_x=0;Y方向偏り（px）,v_y=0;X軸拡散倍率,r_x=1.0;Y軸拡散倍率,r_y=1.0;シード,seed=0;分割数,separate=4;余剰部分,surplus=1;X方向誤差（px）,error_x=10;Y方向誤差（px）,error_y=10;

local progress = obj.track0
local length = obj.track1
local pos_x = obj.track2
local pos_y = obj.track3
seed = math.abs(math.floor(seed))
separate = math.min(math.max(1, math.floor(separate)),16)
r_x = math.max(0, r_x)
r_y = math.max(0, r_y)
local left = -obj.w / 2
local right = obj.w / 2
local top = -obj.h / 2
local bottom = obj.h / 2
local l = 2 ^ separate
local src = {
    ox = obj.ox,
    oy = obj.oy,
    oz = obj.oz,
    cx = obj.cx,
    cy = obj.cy,
    cz = obj.cz,
    rx = obj.rx,
    ry = obj.ry,
    rz = obj.rz,
    alpha = obj.alpha,
    zoom = obj.zoom
}
local clipping_arg = {}

if (progress ~= 0 and src.alpha ~= 0 and src.zoom ~= 0) then
    
    -- 一時バッファへコピー
    obj.copybuffer("tmp", "obj")
    
    -- 値の初期化
    for i = 1, separate do

        -- 乱数生成
        local cx = obj.rand(pos_x - error_x, pos_x + error_x, i, seed * 10 + 1)
        local cy = obj.rand(pos_y - error_y, pos_y + error_y, i, seed * 10 + 2)
        local deg = math.floor(obj.rand(1, 180, i, seed * 10 + 3))
        
        -- 生成結果を基に関数情報を設定
        local add_i = #clipping_arg + 1
        local slope = 0
        local intercept = 0
        local non_disp = 0
        local continue = 1

        if (deg ~= 90) then
            slope = math.tan(math.pi * deg / 180)
            intercept = cy - (slope * cx)
        end

        if (add_i ~= 1) then
            for j = 1, add_i - 1 do
                if ((deg ~= 90 and clipping_arg[j].slope == slope and clipping_arg[j].intercept == intercept) or 
                    (deg == 90 and clipping_arg[j].cx == cx)) then
                    continue = 0
                end
            end
        end

        if (continue == 1) then
                
            -- 境界がオブジェクト内部を通過しない可能性を検証
            if (slope > 90) then
                if (slope * (left + cx) + cy < top) then
                    non_disp = -1
                elseif (slope * (right + cx) + cy > bottom) then
                    non_disp = 1
                end
            elseif (slope < 90) then
                if (slope * (right + cx) + cy < top) then
                    non_disp = 1
                elseif (slope * (left + cx) + cy > bottom) then
                    non_disp = -1
                end
            else
                if (cx < left) then
                    non_disp = -1
                elseif (cx > right) then
                    non_disp = 1
                end
            end

            -- 値を格納
            clipping_arg[add_i] = {}
            clipping_arg[add_i].cx = cx
            clipping_arg[add_i].cy = cy
            clipping_arg[add_i].deg = deg
            clipping_arg[add_i].slope = slope
            clipping_arg[add_i].intercept = intercept
            clipping_arg[add_i].non_disp = non_disp
            clipping_arg[add_i].left = {}
            clipping_arg[add_i].right = {}
            clipping_arg[add_i].inner_top = {}
            clipping_arg[add_i].inner_bottom = {}
            clipping_arg[add_i].outer_top = {}
            clipping_arg[add_i].outer_bottom = {}
        end
    end

    separate = #clipping_arg    
    l = 2 ^ separate

    -- 値の位置関係を検討
    for i = 1, separate do
        for j = i, separate do
            if (i ~= j) then
                -- 二本の境界が平行かどうかを検証する
                if (clipping_arg[i].deg == clipping_arg[j].deg) then
                    -- 平行である場合
                    -- 切片を用いて検討する
                    if (clipping_arg[i].deg == 90) then
                        if (clipping_arg[i].cx < clipping_arg[j].cx) then
                            table.insert(clipping_arg[i].right, j)
                        else
                            table.insert(clipping_arg[i].left, j)
                        end
                    elseif (clipping_arg[i].intercept > clipping_arg[j].intercept) then
                        table.insert(clipping_arg[i].right, j)
                    else
                        table.insert(clipping_arg[i].left, j)
                    end
                else
                    -- 平行ではない場合
                    -- 交点を求めて検討する
                    local pt = {}
                    if (clipping_arg[i].deg == 90) then
                        pt.x = clipping_arg[i].cx
                        pt.y = clipping_arg[j].slope * pt.x + clipping_arg[j].intercept
                    elseif (clipping_arg[j].deg == 90) then
                        pt.x = clipping_arg[j].cx
                        pt.y = clipping_arg[i].slope * pt.x + clipping_arg[i].intercept
                    else
                        pt.x = (clipping_arg[i].intercept - clipping_arg[j].intercept) / (clipping_arg[j].slope - clipping_arg[i].slope)
                        pt.y = clipping_arg[i].slope * pt.x + clipping_arg[i].intercept
                    end

                    -- オブジェクト外部に交点がある場合を検討する
                    if (pt.y < top) then
                        -- 上側にある場合
                        if (clipping_arg[i].deg < clipping_arg[j].deg) then
                            table.insert(clipping_arg[i].left, j)
                        else
                            table.insert(clipping_arg[i].right, j)
                        end
                    elseif (pt.y > bottom) then
                        -- 下側にある場合
                        if (clipping_arg[i].deg < clipping_arg[j].deg) then
                            table.insert(clipping_arg[i].right, j)
                        else
                            table.insert(clipping_arg[i].left, j)
                        end
                    elseif (pt.x < left) then
                        -- 左側にある場合
                        if (math.max(clipping_arg[i].deg, clipping_arg[j].deg) < 90) then
                            -- 上側と同じ挙動
                            if (clipping_arg[i].deg < clipping_arg[j].deg) then
                                table.insert(clipping_arg[i].left, j)
                            else
                                table.insert(clipping_arg[i].right, j)
                            end
                        elseif (math.min(clipping_arg[i].deg, clipping_arg[j].deg) > 90) then
                            -- 下側と同じ挙動
                            if (clipping_arg[i].deg < clipping_arg[j].deg) then
                                table.insert(clipping_arg[i].right, j)
                            else
                                table.insert(clipping_arg[i].left, j)
                            end
                        else
                            -- 左側固有の挙動
                            if (clipping_arg[i].deg < clipping_arg[j].deg) then
                                table.insert(clipping_arg[i].outer_top, j)
                            else
                                table.insert(clipping_arg[i].outer_bottom, j)
                            end
                        end
                    elseif (pt.x > right) then
                        -- 右側にある場合
                        if (math.min(clipping_arg[i].deg, clipping_arg[j].deg) > 90) then
                            -- 上側と同じ挙動
                            if (clipping_arg[i].deg < clipping_arg[j].deg) then
                                table.insert(clipping_arg[i].left, j)
                            else
                                table.insert(clipping_arg[i].right, j)
                            end
                        elseif (math.max(clipping_arg[i].deg, clipping_arg[j].deg) < 90) then
                            -- 下側と同じ挙動
                            if (clipping_arg[i].deg < clipping_arg[j].deg) then
                                table.insert(clipping_arg[i].right, j)
                            else
                                table.insert(clipping_arg[i].left, j)
                            end
                        else
                            if (clipping_arg[i].deg < clipping_arg[j].deg) then
                                table.insert(clipping_arg[i].inner_bottom, j)
                            else
                                table.insert(clipping_arg[i].inner_top, j)
                            end
                        end
                    end
                end
            end
        end
    end

    -- 描画
    for i = 0, l - 1 do
        local continue = 1
        local reverse = {}
        local clip = {}

        -- 変数の初期化
        for j = 1, separate do
            reverse[j] = (((i % (2 ^ j)) >= (2 ^ (j - 1))) and 1 or 0)
            clip[j] = 1
        end

        for j = 1, separate do
            if (continue == 1 and clip[j]) then
                if (reverse[j] == 0) then
                    -- 反転しない場合
                    for idx, lefter in pairs(clipping_arg[j].left) do
                        -- 左側に別の境界がある場合
                        if (reverse[lefter] == 0) then
                            clip[lefter] = 0
                        else
                            continue = 0
                        end
                    end
                    for idx, righter in pairs(clipping_arg[j].right) do
                        -- 右側に別の境界がある場合
                        if (reverse[righter] == 0) then
                            clip[j] = 0
                        end
                    end
                    for idx, inner_top in pairs(clipping_arg[j].inner_top) do
                        -- 内部方向の上側に別の境界がある場合
                        if (reverse[inner_top] == 0) then
                            continue = 0
                        else
                            clip[inner_top] = 0
                        end
                    end
                    for idx, inner_bottom in pairs(clipping_arg[j].inner_bottom) do
                        -- 内部方向の下側に別の境界がある場合
                        if (reverse[inner_bottom] == 0) then
                            continue = 0
                        else
                            clip[inner_bottom] = 0
                        end
                    end
                    for idx, outer_top in pairs(clipping_arg[j].outer_top) do
                        -- 外部方向の上側に別の境界がある場合
                        if (reverse[outer_top] == 1) then
                            clip[j] = 0
                        end
                    end
                    for idx, outer_bottom in pairs(clipping_arg[j].outer_bottom) do
                        -- 外部方向の下側に別の境界がある場合
                        if (reverse[outer_bottom] == 1) then
                            clip[j] = 0
                        end
                    end
                else
                    -- 反転する場合
                    for idx, lefter in pairs(clipping_arg[j].left) do
                        -- 左側に別の境界が存在する場合
                        if (reverse[lefter] == 1) then
                            clip[j] = 0
                        end
                    end
                    for idx, righter in pairs(clipping_arg[j].right) do
                        -- 右側に別の境界がある場合
                        if (reverse[righter] == 0) then
                            continue = 0
                        else
                            clip[righter] = 0
                        end
                    end
                    for idx, inner_top in pairs(clipping_arg[j].inner_top) do
                        -- 内部方向の上側に別の境界がある場合
                        if (reverse[inner_top] == 0) then
                            clip[j] = 0
                        end
                    end
                    for idx, inner_bottom in pairs(clipping_arg[j].inner_bottom) do
                        -- 内部方向の下側に別の境界がある場合
                        if (reverse[inner_bottom] == 0) then
                            clip[j] = 0
                        end
                    end
                    for idx, outer_top in pairs(clipping_arg[j].outer_top) do
                        -- 外部方向の上側に別の境界がある場合
                        if (reverse[outer_top] == 0) then
                            clip[outer_top] = 0
                        else
                            continue = 0
                        end
                    end
                    for idx, outer_bottom in pairs(clipping_arg[j].outer_bottom) do
                        -- 外部方向の下側に別の境界がある場合
                        if (reverse[outer_bottom] == 0) then
                            clip[outer_bottom] = 0
                        else
                            continue = 0
                        end
                    end
                end
            end
        end

        if (continue == 1) then
            obj.load("tempbuffer")

            -- 斜めクリッピング
            for j = 1, separate do
                if (clip[j] == 1) then
                    local cx = clipping_arg[j].cx
                    local cy = clipping_arg[j].cy
                    local deg = clipping_arg[j].deg
                    if (reverse[j] == 1) then
                        deg = deg + 180
                    end
                    cx = cx - math.sin(math.pi * deg / 180) * surplus
                    cy = cy + math.cos(math.pi * deg / 180) * surplus
                    obj.effect(
                        "斜めクリッピング",
                        "中心X", cx,
                        "中心Y", cy,
                        "角度", deg,
                        "ぼかし", 0)
                end
            end

            obj.ox = src.ox
            obj.oy = src.oy
            obj.oz = src.oz
            obj.cx = src.cx
            obj.cy = src.cy
            obj.cz = src.cz
            obj.rx = src.rx
            obj.ry = src.ry
            obj.rz = src.rz
            obj.alpha = src.alpha
            obj.zoom = src.zoom
            obj.effect()

            local mov_deg = obj.rand(1, 360, i, seed * 10 + 4)
            local x = length * math.cos(math.pi * mov_deg / 180) * r_x + v_x
            local y = length * math.sin(math.pi * mov_deg / 180) * r_y + v_y
            local rate = progress / 100
            obj.draw(x * rate, y * rate)
        end
    end
end



@領域内ランダム拡散TA
--track0:進行度,0,100,10,0.01
--track1:拡散距離,0,300,30,0.01
--track2:開始文字数,0,1000,0,1
--track3:終了文字数,0,1000,2,1
--check0:効果適用範囲を可視化,0
--dialog:X方向偏り（px）,v_x=0;Y方向偏り（px）,v_y=0;X軸拡散倍率,r_x=1.0;Y軸拡散倍率,r_y=1.0;シード,seed=0;分割数,separate=4;余剰部分,surplus=1;

local progress = obj.track0
local length = obj.track1
local begin_i = math.min(obj.track2, obj.track3)
local end_i = math.max(obj.track2, obj.track3)
local debugging = obj.check0
seed = math.abs(math.floor(seed))
separate = math.min(math.max(1, math.floor(separate)),16)
r_x = math.max(0, r_x)
r_y = math.max(0, r_y)
local left = -obj.w / 2
local right = obj.w / 2
local top = -obj.h / 2
local bottom = obj.h / 2
local l = 2 ^ separate
local src = {
    ox = obj.ox,
    oy = obj.oy,
    oz = obj.oz,
    cx = obj.cx,
    cy = obj.cy,
    cz = obj.cz,
    rx = obj.rx,
    ry = obj.ry,
    rz = obj.rz,
    alpha = obj.alpha,
    zoom = obj.zoom
}
local clipping_arg = {}

if (progress ~= 0 and src.alpha ~= 0 and src.zoom ~= 0 and (obj.index + 1) >= begin_i and (obj.index + 1) <= end_i) then
    
    if (debugging == false) then

        -- 一時バッファへコピー
        obj.copybuffer("tmp", "obj")
        
        -- 値の初期化
        for i = 1, separate do

            -- 乱数生成
            local cx = obj.rand(left, right, i, seed * 10 + 1)
            local cy = obj.rand(top, bottom, i, seed * 10 + 2)
            local deg = math.floor(obj.rand(1, 180, i, seed * 10 + 3))
            
            -- 生成結果を基に関数情報を設定
            local add_i = #clipping_arg + 1
            local slope = 0
            local intercept = 0
            local non_disp = 0
            local continue = 1

            if (deg ~= 90) then
                slope = math.tan(math.pi * deg / 180)
                intercept = cy - (slope * cx)
            end

            if (add_i ~= 1) then
                for j = 1, add_i - 1 do
                    if ((deg ~= 90 and clipping_arg[j].slope == slope and clipping_arg[j].intercept == intercept) or 
                        (deg == 90 and clipping_arg[j].cx == cx)) then
                        continue = 0
                    end
                end
            end

            if (continue == 1) then
                    
                -- 境界がオブジェクト内部を通過しない可能性を検証
                if (slope > 90) then
                    if (slope * (left + cx) + cy < top) then
                        non_disp = -1
                    elseif (slope * (right + cx) + cy > bottom) then
                        non_disp = 1
                    end
                elseif (slope < 90) then
                    if (slope * (right + cx) + cy < top) then
                        non_disp = 1
                    elseif (slope * (left + cx) + cy > bottom) then
                        non_disp = -1
                    end
                else
                    if (cx < left) then
                        non_disp = -1
                    elseif (cx > right) then
                        non_disp = 1
                    end
                end

                -- 値を格納
                clipping_arg[add_i] = {}
                clipping_arg[add_i].cx = cx
                clipping_arg[add_i].cy = cy
                clipping_arg[add_i].deg = deg
                clipping_arg[add_i].slope = slope
                clipping_arg[add_i].intercept = intercept
                clipping_arg[add_i].non_disp = non_disp
                clipping_arg[add_i].left = {}
                clipping_arg[add_i].right = {}
                clipping_arg[add_i].inner_top = {}
                clipping_arg[add_i].inner_bottom = {}
                clipping_arg[add_i].outer_top = {}
                clipping_arg[add_i].outer_bottom = {}
            end
        end

        separate = #clipping_arg    
        l = 2 ^ separate

        -- 値の位置関係を検討
        for i = 1, separate do
            for j = i, separate do
                if (i ~= j) then
                    -- 二本の境界が平行かどうかを検証する
                    if (clipping_arg[i].deg == clipping_arg[j].deg) then
                        -- 平行である場合
                        -- 切片を用いて検討する
                        if (clipping_arg[i].deg == 90) then
                            if (clipping_arg[i].cx < clipping_arg[j].cx) then
                                table.insert(clipping_arg[i].right, j)
                            else
                                table.insert(clipping_arg[i].left, j)
                            end
                        elseif (clipping_arg[i].intercept > clipping_arg[j].intercept) then
                            table.insert(clipping_arg[i].right, j)
                        else
                            table.insert(clipping_arg[i].left, j)
                        end
                    else
                        -- 平行ではない場合
                        -- 交点を求めて検討する
                        local pt = {}
                        if (clipping_arg[i].deg == 90) then
                            pt.x = clipping_arg[i].cx
                            pt.y = clipping_arg[j].slope * pt.x + clipping_arg[j].intercept
                        elseif (clipping_arg[j].deg == 90) then
                            pt.x = clipping_arg[j].cx
                            pt.y = clipping_arg[i].slope * pt.x + clipping_arg[i].intercept
                        else
                            pt.x = (clipping_arg[i].intercept - clipping_arg[j].intercept) / (clipping_arg[j].slope - clipping_arg[i].slope)
                            pt.y = clipping_arg[i].slope * pt.x + clipping_arg[i].intercept
                        end

                        -- オブジェクト外部に交点がある場合を検討する
                        if (pt.y < top) then
                            -- 上側にある場合
                            if (clipping_arg[i].deg < clipping_arg[j].deg) then
                                table.insert(clipping_arg[i].left, j)
                            else
                                table.insert(clipping_arg[i].right, j)
                            end
                        elseif (pt.y > bottom) then
                            -- 下側にある場合
                            if (clipping_arg[i].deg < clipping_arg[j].deg) then
                                table.insert(clipping_arg[i].right, j)
                            else
                                table.insert(clipping_arg[i].left, j)
                            end
                        elseif (pt.x < left) then
                            -- 左側にある場合
                            if (math.max(clipping_arg[i].deg, clipping_arg[j].deg) < 90) then
                                -- 上側と同じ挙動
                                if (clipping_arg[i].deg < clipping_arg[j].deg) then
                                    table.insert(clipping_arg[i].left, j)
                                else
                                    table.insert(clipping_arg[i].right, j)
                                end
                            elseif (math.min(clipping_arg[i].deg, clipping_arg[j].deg) > 90) then
                                -- 下側と同じ挙動
                                if (clipping_arg[i].deg < clipping_arg[j].deg) then
                                    table.insert(clipping_arg[i].right, j)
                                else
                                    table.insert(clipping_arg[i].left, j)
                                end
                            else
                                -- 左側固有の挙動
                                if (clipping_arg[i].deg < clipping_arg[j].deg) then
                                    table.insert(clipping_arg[i].outer_top, j)
                                else
                                    table.insert(clipping_arg[i].outer_bottom, j)
                                end
                            end
                        elseif (pt.x > right) then
                            -- 右側にある場合
                            if (math.min(clipping_arg[i].deg, clipping_arg[j].deg) > 90) then
                                -- 上側と同じ挙動
                                if (clipping_arg[i].deg < clipping_arg[j].deg) then
                                    table.insert(clipping_arg[i].left, j)
                                else
                                    table.insert(clipping_arg[i].right, j)
                                end
                            elseif (math.max(clipping_arg[i].deg, clipping_arg[j].deg) < 90) then
                                -- 下側と同じ挙動
                                if (clipping_arg[i].deg < clipping_arg[j].deg) then
                                    table.insert(clipping_arg[i].right, j)
                                else
                                    table.insert(clipping_arg[i].left, j)
                                end
                            else
                                if (clipping_arg[i].deg < clipping_arg[j].deg) then
                                    table.insert(clipping_arg[i].inner_bottom, j)
                                else
                                    table.insert(clipping_arg[i].inner_top, j)
                                end
                            end
                        end
                    end
                end
            end
        end

        -- 描画
        for i = 0, l - 1 do
            local continue = 1
            local reverse = {}
            local clip = {}

            -- 変数の初期化
            for j = 1, separate do
                reverse[j] = (((i % (2 ^ j)) >= (2 ^ (j - 1))) and 1 or 0)
                clip[j] = 1
            end

            for j = 1, separate do
                if (continue == 1 and clip[j]) then
                    if (reverse[j] == 0) then
                        -- 反転しない場合
                        for idx, lefter in pairs(clipping_arg[j].left) do
                            -- 左側に別の境界がある場合
                            if (reverse[lefter] == 0) then
                                clip[lefter] = 0
                            else
                                continue = 0
                            end
                        end
                        for idx, righter in pairs(clipping_arg[j].right) do
                            -- 右側に別の境界がある場合
                            if (reverse[righter] == 0) then
                                clip[j] = 0
                            end
                        end
                        for idx, inner_top in pairs(clipping_arg[j].inner_top) do
                            -- 内部方向の上側に別の境界がある場合
                            if (reverse[inner_top] == 0) then
                                continue = 0
                            else
                                clip[inner_top] = 0
                            end
                        end
                        for idx, inner_bottom in pairs(clipping_arg[j].inner_bottom) do
                            -- 内部方向の下側に別の境界がある場合
                            if (reverse[inner_bottom] == 0) then
                                continue = 0
                            else
                                clip[inner_bottom] = 0
                            end
                        end
                        for idx, outer_top in pairs(clipping_arg[j].outer_top) do
                            -- 外部方向の上側に別の境界がある場合
                            if (reverse[outer_top] == 1) then
                                clip[j] = 0
                            end
                        end
                        for idx, outer_bottom in pairs(clipping_arg[j].outer_bottom) do
                            -- 外部方向の下側に別の境界がある場合
                            if (reverse[outer_bottom] == 1) then
                                clip[j] = 0
                            end
                        end
                    else
                        -- 反転する場合
                        for idx, lefter in pairs(clipping_arg[j].left) do
                            -- 左側に別の境界が存在する場合
                            if (reverse[lefter] == 1) then
                                clip[j] = 0
                            end
                        end
                        for idx, righter in pairs(clipping_arg[j].right) do
                            -- 右側に別の境界がある場合
                            if (reverse[righter] == 0) then
                                continue = 0
                            else
                                clip[righter] = 0
                            end
                        end
                        for idx, inner_top in pairs(clipping_arg[j].inner_top) do
                            -- 内部方向の上側に別の境界がある場合
                            if (reverse[inner_top] == 0) then
                                clip[j] = 0
                            end
                        end
                        for idx, inner_bottom in pairs(clipping_arg[j].inner_bottom) do
                            -- 内部方向の下側に別の境界がある場合
                            if (reverse[inner_bottom] == 0) then
                                clip[j] = 0
                            end
                        end
                        for idx, outer_top in pairs(clipping_arg[j].outer_top) do
                            -- 外部方向の上側に別の境界がある場合
                            if (reverse[outer_top] == 0) then
                                clip[outer_top] = 0
                            else
                                continue = 0
                            end
                        end
                        for idx, outer_bottom in pairs(clipping_arg[j].outer_bottom) do
                            -- 外部方向の下側に別の境界がある場合
                            if (reverse[outer_bottom] == 0) then
                                clip[outer_bottom] = 0
                            else
                                continue = 0
                            end
                        end
                    end
                end
            end

            if (continue == 1) then
                obj.load("tempbuffer")

                -- 斜めクリッピング
                for j = 1, separate do
                    if (clip[j] == 1) then
                        local cx = clipping_arg[j].cx
                        local cy = clipping_arg[j].cy
                        local deg = clipping_arg[j].deg
                        if (reverse[j] == 1) then
                            deg = deg + 180
                        end
                        cx = cx - math.sin(math.pi * deg / 180) * surplus
                        cy = cy + math.cos(math.pi * deg / 180) * surplus
                        obj.effect(
                            "斜めクリッピング",
                            "中心X", cx,
                            "中心Y", cy,
                            "角度", deg,
                            "ぼかし", 0)
                    end
                end

                obj.ox = src.ox
                obj.oy = src.oy
                obj.oz = src.oz
                obj.cx = src.cx
                obj.cy = src.cy
                obj.cz = src.cz
                obj.rx = src.rx
                obj.ry = src.ry
                obj.rz = src.rz
                obj.alpha = src.alpha
                obj.zoom = src.zoom
                obj.effect()

                local mov_deg = obj.rand(1, 360, i, seed * 10 + 4)
                local x = length * math.cos(math.pi * mov_deg / 180) * r_x + v_x
                local y = length * math.sin(math.pi * mov_deg / 180) * r_y + v_y
                local rate = progress / 100
                obj.draw(x * rate, y * rate)
            end
        end
    else
        obj.effect("単色化", "強さ", 80, "輝度を保持する", 0, "color", 0x00ff00)
    end
end


@進行度固定
--track0:シード,0,1000,0,1
--track1:拡散距離,0,300,30,0.01
--dialog:X方向偏り（px）,v_x=0;Y方向偏り（px）,v_y=0;X軸拡散倍率,r_x=1.0;Y軸拡散倍率,r_y=1.0;シード,seed=0;分割数,separate=4;余剰部分,surplus=1;

local seed = obj.track0
local length = obj.track1
seed = math.abs(math.floor(seed))
separate = math.min(math.max(1, math.floor(separate)),16)
r_x = math.max(0, r_x)
r_y = math.max(0, r_y)
local left = -obj.w / 2
local right = obj.w / 2
local top = -obj.h / 2
local bottom = obj.h / 2
local l = 2 ^ separate
local src = {
    ox = obj.ox,
    oy = obj.oy,
    oz = obj.oz,
    cx = obj.cx,
    cy = obj.cy,
    cz = obj.cz,
    rx = obj.rx,
    ry = obj.ry,
    rz = obj.rz,
    alpha = obj.alpha,
    zoom = obj.zoom
}
local clipping_arg = {}

if (src.alpha ~= 0 and src.zoom ~= 0) then
    
    -- 一時バッファへコピー
    obj.copybuffer("tmp", "obj")
    
    -- 値の初期化
    for i = 1, separate do

        -- 乱数生成
        local cx = obj.rand(left, right, i, seed * 10 + 1)
        local cy = obj.rand(top, bottom, i, seed * 10 + 2)
        local deg = math.floor(obj.rand(1, 180, i, seed * 10 + 3))
        
        -- 生成結果を基に関数情報を設定
        local add_i = #clipping_arg + 1
        local slope = 0
        local intercept = 0
        local non_disp = 0
        local continue = 1

        if (deg ~= 90) then
            slope = math.tan(math.pi * deg / 180)
            intercept = cy - (slope * cx)
        end

        if (add_i ~= 1) then
            for j = 1, add_i - 1 do
                if ((deg ~= 90 and clipping_arg[j].slope == slope and clipping_arg[j].intercept == intercept) or 
                    (deg == 90 and clipping_arg[j].cx == cx)) then
                    continue = 0
                end
            end
        end

        if (continue == 1) then
                
            -- 境界がオブジェクト内部を通過しない可能性を検証
            if (slope > 90) then
                if (slope * (left + cx) + cy < top) then
                    non_disp = -1
                elseif (slope * (right + cx) + cy > bottom) then
                    non_disp = 1
                end
            elseif (slope < 90) then
                if (slope * (right + cx) + cy < top) then
                    non_disp = 1
                elseif (slope * (left + cx) + cy > bottom) then
                    non_disp = -1
                end
            else
                if (cx < left) then
                    non_disp = -1
                elseif (cx > right) then
                    non_disp = 1
                end
            end

            -- 値を格納
            clipping_arg[add_i] = {}
            clipping_arg[add_i].cx = cx
            clipping_arg[add_i].cy = cy
            clipping_arg[add_i].deg = deg
            clipping_arg[add_i].slope = slope
            clipping_arg[add_i].intercept = intercept
            clipping_arg[add_i].non_disp = non_disp
            clipping_arg[add_i].left = {}
            clipping_arg[add_i].right = {}
            clipping_arg[add_i].inner_top = {}
            clipping_arg[add_i].inner_bottom = {}
            clipping_arg[add_i].outer_top = {}
            clipping_arg[add_i].outer_bottom = {}
        end
    end

    separate = #clipping_arg    
    l = 2 ^ separate

    -- 値の位置関係を検討
    for i = 1, separate do
        for j = i, separate do
            if (i ~= j) then
                -- 二本の境界が平行かどうかを検証する
                if (clipping_arg[i].deg == clipping_arg[j].deg) then
                    -- 平行である場合
                    -- 切片を用いて検討する
                    if (clipping_arg[i].deg == 90) then
                        if (clipping_arg[i].cx < clipping_arg[j].cx) then
                            table.insert(clipping_arg[i].right, j)
                        else
                            table.insert(clipping_arg[i].left, j)
                        end
                    elseif (clipping_arg[i].intercept > clipping_arg[j].intercept) then
                        table.insert(clipping_arg[i].right, j)
                    else
                        table.insert(clipping_arg[i].left, j)
                    end
                else
                    -- 平行ではない場合
                    -- 交点を求めて検討する
                    local pt = {}
                    if (clipping_arg[i].deg == 90) then
                        pt.x = clipping_arg[i].cx
                        pt.y = clipping_arg[j].slope * pt.x + clipping_arg[j].intercept
                    elseif (clipping_arg[j].deg == 90) then
                        pt.x = clipping_arg[j].cx
                        pt.y = clipping_arg[i].slope * pt.x + clipping_arg[i].intercept
                    else
                        pt.x = (clipping_arg[i].intercept - clipping_arg[j].intercept) / (clipping_arg[j].slope - clipping_arg[i].slope)
                        pt.y = clipping_arg[i].slope * pt.x + clipping_arg[i].intercept
                    end

                    -- オブジェクト外部に交点がある場合を検討する
                    if (pt.y < top) then
                        -- 上側にある場合
                        if (clipping_arg[i].deg < clipping_arg[j].deg) then
                            table.insert(clipping_arg[i].left, j)
                        else
                            table.insert(clipping_arg[i].right, j)
                        end
                    elseif (pt.y > bottom) then
                        -- 下側にある場合
                        if (clipping_arg[i].deg < clipping_arg[j].deg) then
                            table.insert(clipping_arg[i].right, j)
                        else
                            table.insert(clipping_arg[i].left, j)
                        end
                    elseif (pt.x < left) then
                        -- 左側にある場合
                        if (math.max(clipping_arg[i].deg, clipping_arg[j].deg) < 90) then
                            -- 上側と同じ挙動
                            if (clipping_arg[i].deg < clipping_arg[j].deg) then
                                table.insert(clipping_arg[i].left, j)
                            else
                                table.insert(clipping_arg[i].right, j)
                            end
                        elseif (math.min(clipping_arg[i].deg, clipping_arg[j].deg) > 90) then
                            -- 下側と同じ挙動
                            if (clipping_arg[i].deg < clipping_arg[j].deg) then
                                table.insert(clipping_arg[i].right, j)
                            else
                                table.insert(clipping_arg[i].left, j)
                            end
                        else
                            -- 左側固有の挙動
                            if (clipping_arg[i].deg < clipping_arg[j].deg) then
                                table.insert(clipping_arg[i].outer_top, j)
                            else
                                table.insert(clipping_arg[i].outer_bottom, j)
                            end
                        end
                    elseif (pt.x > right) then
                        -- 右側にある場合
                        if (math.min(clipping_arg[i].deg, clipping_arg[j].deg) > 90) then
                            -- 上側と同じ挙動
                            if (clipping_arg[i].deg < clipping_arg[j].deg) then
                                table.insert(clipping_arg[i].left, j)
                            else
                                table.insert(clipping_arg[i].right, j)
                            end
                        elseif (math.max(clipping_arg[i].deg, clipping_arg[j].deg) < 90) then
                            -- 下側と同じ挙動
                            if (clipping_arg[i].deg < clipping_arg[j].deg) then
                                table.insert(clipping_arg[i].right, j)
                            else
                                table.insert(clipping_arg[i].left, j)
                            end
                        else
                            if (clipping_arg[i].deg < clipping_arg[j].deg) then
                                table.insert(clipping_arg[i].inner_bottom, j)
                            else
                                table.insert(clipping_arg[i].inner_top, j)
                            end
                        end
                    end
                end
            end
        end
    end

    -- 描画
    for i = 0, l - 1 do
        local continue = 1
        local reverse = {}
        local clip = {}

        -- 変数の初期化
        for j = 1, separate do
            reverse[j] = (((i % (2 ^ j)) >= (2 ^ (j - 1))) and 1 or 0)
            clip[j] = 1
        end

        for j = 1, separate do
            if (continue == 1 and clip[j]) then
                if (reverse[j] == 0) then
                    -- 反転しない場合
                    for idx, lefter in pairs(clipping_arg[j].left) do
                        -- 左側に別の境界がある場合
                        if (reverse[lefter] == 0) then
                            clip[lefter] = 0
                        else
                            continue = 0
                        end
                    end
                    for idx, righter in pairs(clipping_arg[j].right) do
                        -- 右側に別の境界がある場合
                        if (reverse[righter] == 0) then
                            clip[j] = 0
                        end
                    end
                    for idx, inner_top in pairs(clipping_arg[j].inner_top) do
                        -- 内部方向の上側に別の境界がある場合
                        if (reverse[inner_top] == 0) then
                            continue = 0
                        else
                            clip[inner_top] = 0
                        end
                    end
                    for idx, inner_bottom in pairs(clipping_arg[j].inner_bottom) do
                        -- 内部方向の下側に別の境界がある場合
                        if (reverse[inner_bottom] == 0) then
                            continue = 0
                        else
                            clip[inner_bottom] = 0
                        end
                    end
                    for idx, outer_top in pairs(clipping_arg[j].outer_top) do
                        -- 外部方向の上側に別の境界がある場合
                        if (reverse[outer_top] == 1) then
                            clip[j] = 0
                        end
                    end
                    for idx, outer_bottom in pairs(clipping_arg[j].outer_bottom) do
                        -- 外部方向の下側に別の境界がある場合
                        if (reverse[outer_bottom] == 1) then
                            clip[j] = 0
                        end
                    end
                else
                    -- 反転する場合
                    for idx, lefter in pairs(clipping_arg[j].left) do
                        -- 左側に別の境界が存在する場合
                        if (reverse[lefter] == 1) then
                            clip[j] = 0
                        end
                    end
                    for idx, righter in pairs(clipping_arg[j].right) do
                        -- 右側に別の境界がある場合
                        if (reverse[righter] == 0) then
                            continue = 0
                        else
                            clip[righter] = 0
                        end
                    end
                    for idx, inner_top in pairs(clipping_arg[j].inner_top) do
                        -- 内部方向の上側に別の境界がある場合
                        if (reverse[inner_top] == 0) then
                            clip[j] = 0
                        end
                    end
                    for idx, inner_bottom in pairs(clipping_arg[j].inner_bottom) do
                        -- 内部方向の下側に別の境界がある場合
                        if (reverse[inner_bottom] == 0) then
                            clip[j] = 0
                        end
                    end
                    for idx, outer_top in pairs(clipping_arg[j].outer_top) do
                        -- 外部方向の上側に別の境界がある場合
                        if (reverse[outer_top] == 0) then
                            clip[outer_top] = 0
                        else
                            continue = 0
                        end
                    end
                    for idx, outer_bottom in pairs(clipping_arg[j].outer_bottom) do
                        -- 外部方向の下側に別の境界がある場合
                        if (reverse[outer_bottom] == 0) then
                            clip[outer_bottom] = 0
                        else
                            continue = 0
                        end
                    end
                end
            end
        end

        if (continue == 1) then
            obj.load("tempbuffer")

            -- 斜めクリッピング
            for j = 1, separate do
                if (clip[j] == 1) then
                    local cx = clipping_arg[j].cx
                    local cy = clipping_arg[j].cy
                    local deg = clipping_arg[j].deg
                    if (reverse[j] == 1) then
                        deg = deg + 180
                    end
                    cx = cx - math.sin(math.pi * deg / 180) * surplus
                    cy = cy + math.cos(math.pi * deg / 180) * surplus
                    obj.effect(
                        "斜めクリッピング",
                        "中心X", cx,
                        "中心Y", cy,
                        "角度", deg,
                        "ぼかし", 0)
                end
            end

            obj.ox = src.ox
            obj.oy = src.oy
            obj.oz = src.oz
            obj.cx = src.cx
            obj.cy = src.cy
            obj.cz = src.cz
            obj.rx = src.rx
            obj.ry = src.ry
            obj.rz = src.rz
            obj.alpha = src.alpha
            obj.zoom = src.zoom
            obj.effect()

            local mov_deg = obj.rand(1, 360, i, seed * 10 + 4)
            local x = length * math.cos(math.pi * mov_deg / 180) * r_x + v_x
            local y = length * math.sin(math.pi * mov_deg / 180) * r_y + v_y
            obj.draw(x, y)
        end
    end
end


@進行度固定TA
--track0:シード,0,1000,0,1
--track1:拡散距離,0,300,30,0.01
--track2:開始文字数,0,1000,0,1
--track3:終了文字数,0,1000,2,1
--check0:効果適用範囲を可視化,0
--dialog:X方向偏り（px）,v_x=0;Y方向偏り（px）,v_y=0;X軸拡散倍率,r_x=1.0;Y軸拡散倍率,r_y=1.0;分割数,separate=4;余剰部分,surplus=1;

local seed = obj.track0
local length = obj.track1
local begin_i = math.min(obj.track2, obj.track3)
local end_i = math.max(obj.track2, obj.track3)
local debugging = obj.check0
seed = math.abs(math.floor(seed))
separate = math.min(math.max(1, math.floor(separate)),16)
r_x = math.max(0, r_x)
r_y = math.max(0, r_y)
local left = -obj.w / 2
local right = obj.w / 2
local top = -obj.h / 2
local bottom = obj.h / 2
local l = 2 ^ separate
local src = {
    ox = obj.ox,
    oy = obj.oy,
    oz = obj.oz,
    cx = obj.cx,
    cy = obj.cy,
    cz = obj.cz,
    rx = obj.rx,
    ry = obj.ry,
    rz = obj.rz,
    alpha = obj.alpha,
    zoom = obj.zoom
}
local clipping_arg = {}

if (src.alpha ~= 0 and src.zoom ~= 0 and (obj.index + 1) >= begin_i and (obj.index + 1) <= end_i) then
    if (debugging == false) then
        -- 一時バッファへコピー
        obj.copybuffer("tmp", "obj")
        
        -- 値の初期化
        for i = 1, separate do

            -- 乱数生成
            local cx = obj.rand(left, right, i, seed * 10 + 1)
            local cy = obj.rand(top, bottom, i, seed * 10 + 2)
            local deg = math.floor(obj.rand(1, 180, i, seed * 10 + 3))
            
            -- 生成結果を基に関数情報を設定
            local add_i = #clipping_arg + 1
            local slope = 0
            local intercept = 0
            local non_disp = 0
            local continue = 1

            if (deg ~= 90) then
                slope = math.tan(math.pi * deg / 180)
                intercept = cy - (slope * cx)
            end

            if (add_i ~= 1) then
                for j = 1, add_i - 1 do
                    if ((deg ~= 90 and clipping_arg[j].slope == slope and clipping_arg[j].intercept == intercept) or 
                        (deg == 90 and clipping_arg[j].cx == cx)) then
                        continue = 0
                    end
                end
            end

            if (continue == 1) then
                    
                -- 境界がオブジェクト内部を通過しない可能性を検証
                if (slope > 90) then
                    if (slope * (left + cx) + cy < top) then
                        non_disp = -1
                    elseif (slope * (right + cx) + cy > bottom) then
                        non_disp = 1
                    end
                elseif (slope < 90) then
                    if (slope * (right + cx) + cy < top) then
                        non_disp = 1
                    elseif (slope * (left + cx) + cy > bottom) then
                        non_disp = -1
                    end
                else
                    if (cx < left) then
                        non_disp = -1
                    elseif (cx > right) then
                        non_disp = 1
                    end
                end

                -- 値を格納
                clipping_arg[add_i] = {}
                clipping_arg[add_i].cx = cx
                clipping_arg[add_i].cy = cy
                clipping_arg[add_i].deg = deg
                clipping_arg[add_i].slope = slope
                clipping_arg[add_i].intercept = intercept
                clipping_arg[add_i].non_disp = non_disp
                clipping_arg[add_i].left = {}
                clipping_arg[add_i].right = {}
                clipping_arg[add_i].inner_top = {}
                clipping_arg[add_i].inner_bottom = {}
                clipping_arg[add_i].outer_top = {}
                clipping_arg[add_i].outer_bottom = {}
            end
        end

        separate = #clipping_arg    
        l = 2 ^ separate

        -- 値の位置関係を検討
        for i = 1, separate do
            for j = i, separate do
                if (i ~= j) then
                    -- 二本の境界が平行かどうかを検証する
                    if (clipping_arg[i].deg == clipping_arg[j].deg) then
                        -- 平行である場合
                        -- 切片を用いて検討する
                        if (clipping_arg[i].deg == 90) then
                            if (clipping_arg[i].cx < clipping_arg[j].cx) then
                                table.insert(clipping_arg[i].right, j)
                            else
                                table.insert(clipping_arg[i].left, j)
                            end
                        elseif (clipping_arg[i].intercept > clipping_arg[j].intercept) then
                            table.insert(clipping_arg[i].right, j)
                        else
                            table.insert(clipping_arg[i].left, j)
                        end
                    else
                        -- 平行ではない場合
                        -- 交点を求めて検討する
                        local pt = {}
                        if (clipping_arg[i].deg == 90) then
                            pt.x = clipping_arg[i].cx
                            pt.y = clipping_arg[j].slope * pt.x + clipping_arg[j].intercept
                        elseif (clipping_arg[j].deg == 90) then
                            pt.x = clipping_arg[j].cx
                            pt.y = clipping_arg[i].slope * pt.x + clipping_arg[i].intercept
                        else
                            pt.x = (clipping_arg[i].intercept - clipping_arg[j].intercept) / (clipping_arg[j].slope - clipping_arg[i].slope)
                            pt.y = clipping_arg[i].slope * pt.x + clipping_arg[i].intercept
                        end

                        -- オブジェクト外部に交点がある場合を検討する
                        if (pt.y < top) then
                            -- 上側にある場合
                            if (clipping_arg[i].deg < clipping_arg[j].deg) then
                                table.insert(clipping_arg[i].left, j)
                            else
                                table.insert(clipping_arg[i].right, j)
                            end
                        elseif (pt.y > bottom) then
                            -- 下側にある場合
                            if (clipping_arg[i].deg < clipping_arg[j].deg) then
                                table.insert(clipping_arg[i].right, j)
                            else
                                table.insert(clipping_arg[i].left, j)
                            end
                        elseif (pt.x < left) then
                            -- 左側にある場合
                            if (math.max(clipping_arg[i].deg, clipping_arg[j].deg) < 90) then
                                -- 上側と同じ挙動
                                if (clipping_arg[i].deg < clipping_arg[j].deg) then
                                    table.insert(clipping_arg[i].left, j)
                                else
                                    table.insert(clipping_arg[i].right, j)
                                end
                            elseif (math.min(clipping_arg[i].deg, clipping_arg[j].deg) > 90) then
                                -- 下側と同じ挙動
                                if (clipping_arg[i].deg < clipping_arg[j].deg) then
                                    table.insert(clipping_arg[i].right, j)
                                else
                                    table.insert(clipping_arg[i].left, j)
                                end
                            else
                                -- 左側固有の挙動
                                if (clipping_arg[i].deg < clipping_arg[j].deg) then
                                    table.insert(clipping_arg[i].outer_top, j)
                                else
                                    table.insert(clipping_arg[i].outer_bottom, j)
                                end
                            end
                        elseif (pt.x > right) then
                            -- 右側にある場合
                            if (math.min(clipping_arg[i].deg, clipping_arg[j].deg) > 90) then
                                -- 上側と同じ挙動
                                if (clipping_arg[i].deg < clipping_arg[j].deg) then
                                    table.insert(clipping_arg[i].left, j)
                                else
                                    table.insert(clipping_arg[i].right, j)
                                end
                            elseif (math.max(clipping_arg[i].deg, clipping_arg[j].deg) < 90) then
                                -- 下側と同じ挙動
                                if (clipping_arg[i].deg < clipping_arg[j].deg) then
                                    table.insert(clipping_arg[i].right, j)
                                else
                                    table.insert(clipping_arg[i].left, j)
                                end
                            else
                                if (clipping_arg[i].deg < clipping_arg[j].deg) then
                                    table.insert(clipping_arg[i].inner_bottom, j)
                                else
                                    table.insert(clipping_arg[i].inner_top, j)
                                end
                            end
                        end
                    end
                end
            end
        end

        -- 描画
        for i = 0, l - 1 do
            local continue = 1
            local reverse = {}
            local clip = {}

            -- 変数の初期化
            for j = 1, separate do
                reverse[j] = (((i % (2 ^ j)) >= (2 ^ (j - 1))) and 1 or 0)
                clip[j] = 1
            end

            for j = 1, separate do
                if (continue == 1 and clip[j]) then
                    if (reverse[j] == 0) then
                        -- 反転しない場合
                        for idx, lefter in pairs(clipping_arg[j].left) do
                            -- 左側に別の境界がある場合
                            if (reverse[lefter] == 0) then
                                clip[lefter] = 0
                            else
                                continue = 0
                            end
                        end
                        for idx, righter in pairs(clipping_arg[j].right) do
                            -- 右側に別の境界がある場合
                            if (reverse[righter] == 0) then
                                clip[j] = 0
                            end
                        end
                        for idx, inner_top in pairs(clipping_arg[j].inner_top) do
                            -- 内部方向の上側に別の境界がある場合
                            if (reverse[inner_top] == 0) then
                                continue = 0
                            else
                                clip[inner_top] = 0
                            end
                        end
                        for idx, inner_bottom in pairs(clipping_arg[j].inner_bottom) do
                            -- 内部方向の下側に別の境界がある場合
                            if (reverse[inner_bottom] == 0) then
                                continue = 0
                            else
                                clip[inner_bottom] = 0
                            end
                        end
                        for idx, outer_top in pairs(clipping_arg[j].outer_top) do
                            -- 外部方向の上側に別の境界がある場合
                            if (reverse[outer_top] == 1) then
                                clip[j] = 0
                            end
                        end
                        for idx, outer_bottom in pairs(clipping_arg[j].outer_bottom) do
                            -- 外部方向の下側に別の境界がある場合
                            if (reverse[outer_bottom] == 1) then
                                clip[j] = 0
                            end
                        end
                    else
                        -- 反転する場合
                        for idx, lefter in pairs(clipping_arg[j].left) do
                            -- 左側に別の境界が存在する場合
                            if (reverse[lefter] == 1) then
                                clip[j] = 0
                            end
                        end
                        for idx, righter in pairs(clipping_arg[j].right) do
                            -- 右側に別の境界がある場合
                            if (reverse[righter] == 0) then
                                continue = 0
                            else
                                clip[righter] = 0
                            end
                        end
                        for idx, inner_top in pairs(clipping_arg[j].inner_top) do
                            -- 内部方向の上側に別の境界がある場合
                            if (reverse[inner_top] == 0) then
                                clip[j] = 0
                            end
                        end
                        for idx, inner_bottom in pairs(clipping_arg[j].inner_bottom) do
                            -- 内部方向の下側に別の境界がある場合
                            if (reverse[inner_bottom] == 0) then
                                clip[j] = 0
                            end
                        end
                        for idx, outer_top in pairs(clipping_arg[j].outer_top) do
                            -- 外部方向の上側に別の境界がある場合
                            if (reverse[outer_top] == 0) then
                                clip[outer_top] = 0
                            else
                                continue = 0
                            end
                        end
                        for idx, outer_bottom in pairs(clipping_arg[j].outer_bottom) do
                            -- 外部方向の下側に別の境界がある場合
                            if (reverse[outer_bottom] == 0) then
                                clip[outer_bottom] = 0
                            else
                                continue = 0
                            end
                        end
                    end
                end
            end

            if (continue == 1) then
                obj.load("tempbuffer")

                -- 斜めクリッピング
                for j = 1, separate do
                    if (clip[j] == 1) then
                        local cx = clipping_arg[j].cx
                        local cy = clipping_arg[j].cy
                        local deg = clipping_arg[j].deg
                        if (reverse[j] == 1) then
                            deg = deg + 180
                        end
                        cx = cx - math.sin(math.pi * deg / 180) * surplus
                        cy = cy + math.cos(math.pi * deg / 180) * surplus
                        obj.effect(
                            "斜めクリッピング",
                            "中心X", cx,
                            "中心Y", cy,
                            "角度", deg,
                            "ぼかし", 0)
                    end
                end

                obj.ox = src.ox
                obj.oy = src.oy
                obj.oz = src.oz
                obj.cx = src.cx
                obj.cy = src.cy
                obj.cz = src.cz
                obj.rx = src.rx
                obj.ry = src.ry
                obj.rz = src.rz
                obj.alpha = src.alpha
                obj.zoom = src.zoom
                obj.effect()

                local mov_deg = obj.rand(1, 360, i, seed * 10 + 4)
                local x = length * math.cos(math.pi * mov_deg / 180) * r_x + v_x
                local y = length * math.sin(math.pi * mov_deg / 180) * r_y + v_y
                obj.draw(x, y)
            end
        end
    else
        obj.effect("単色化", "強さ", 80, "輝度を保持する", 0, "color", 0x00ff00)
    end
end


@揺れ文字
--track0:間隔(ms),0,5000,250,0.01
--track1:拡散距離,0,30,3,0.01
--dialog:X方向偏り（px）,v_x=0;Y方向偏り（px）,v_y=0;X軸拡散倍率,r_x=1.0;Y軸拡散倍率,r_y=1.0;分割数,separate=4;余剰部分,surplus=5;

local seed = math.floor(obj.time / (obj.track0 / 1000))
local length = obj.track1
seed = math.abs(math.floor(seed))
separate = math.min(math.max(1, math.floor(separate)),16)
r_x = math.max(0, r_x)
r_y = math.max(0, r_y)
local left = -obj.w / 2
local right = obj.w / 2
local top = -obj.h / 2
local bottom = obj.h / 2
local l = 2 ^ separate
local src = {
    ox = obj.ox,
    oy = obj.oy,
    oz = obj.oz,
    cx = obj.cx,
    cy = obj.cy,
    cz = obj.cz,
    rx = obj.rx,
    ry = obj.ry,
    rz = obj.rz,
    alpha = obj.alpha,
    zoom = obj.zoom
}
local clipping_arg = {}

if (progress ~= 0 and src.alpha ~= 0 and src.zoom ~= 0) then
    
    -- 一時バッファへコピー
    obj.copybuffer("tmp", "obj")
    
    -- 値の初期化
    for i = 1, separate do

        -- 乱数生成
        local cx = obj.rand(left, right, i, seed * 10 + 1)
        local cy = obj.rand(top, bottom, i, seed * 10 + 2)
        local deg = math.floor(obj.rand(1, 180, i, seed * 10 + 3))
        
        -- 生成結果を基に関数情報を設定
        local add_i = #clipping_arg + 1
        local slope = 0
        local intercept = 0
        local non_disp = 0
        local continue = 1

        if (deg ~= 90) then
            slope = math.tan(math.pi * deg / 180)
            intercept = cy - (slope * cx)
        end

        if (add_i ~= 1) then
            for j = 1, add_i - 1 do
                if ((deg ~= 90 and clipping_arg[j].slope == slope and clipping_arg[j].intercept == intercept) or 
                    (deg == 90 and clipping_arg[j].cx == cx)) then
                    continue = 0
                end
            end
        end

        if (continue == 1) then
                
            -- 境界がオブジェクト内部を通過しない可能性を検証
            if (slope > 90) then
                if (slope * (left + cx) + cy < top) then
                    non_disp = -1
                elseif (slope * (right + cx) + cy > bottom) then
                    non_disp = 1
                end
            elseif (slope < 90) then
                if (slope * (right + cx) + cy < top) then
                    non_disp = 1
                elseif (slope * (left + cx) + cy > bottom) then
                    non_disp = -1
                end
            else
                if (cx < left) then
                    non_disp = -1
                elseif (cx > right) then
                    non_disp = 1
                end
            end

            -- 値を格納
            clipping_arg[add_i] = {}
            clipping_arg[add_i].cx = cx
            clipping_arg[add_i].cy = cy
            clipping_arg[add_i].deg = deg
            clipping_arg[add_i].slope = slope
            clipping_arg[add_i].intercept = intercept
            clipping_arg[add_i].non_disp = non_disp
            clipping_arg[add_i].left = {}
            clipping_arg[add_i].right = {}
            clipping_arg[add_i].inner_top = {}
            clipping_arg[add_i].inner_bottom = {}
            clipping_arg[add_i].outer_top = {}
            clipping_arg[add_i].outer_bottom = {}
        end
    end

    separate = #clipping_arg    
    l = 2 ^ separate

    -- 値の位置関係を検討
    for i = 1, separate do
        for j = i, separate do
            if (i ~= j) then
                -- 二本の境界が平行かどうかを検証する
                if (clipping_arg[i].deg == clipping_arg[j].deg) then
                    -- 平行である場合
                    -- 切片を用いて検討する
                    if (clipping_arg[i].deg == 90) then
                        if (clipping_arg[i].cx < clipping_arg[j].cx) then
                            table.insert(clipping_arg[i].right, j)
                        else
                            table.insert(clipping_arg[i].left, j)
                        end
                    elseif (clipping_arg[i].intercept > clipping_arg[j].intercept) then
                        table.insert(clipping_arg[i].right, j)
                    else
                        table.insert(clipping_arg[i].left, j)
                    end
                else
                    -- 平行ではない場合
                    -- 交点を求めて検討する
                    local pt = {}
                    if (clipping_arg[i].deg == 90) then
                        pt.x = clipping_arg[i].cx
                        pt.y = clipping_arg[j].slope * pt.x + clipping_arg[j].intercept
                    elseif (clipping_arg[j].deg == 90) then
                        pt.x = clipping_arg[j].cx
                        pt.y = clipping_arg[i].slope * pt.x + clipping_arg[i].intercept
                    else
                        pt.x = (clipping_arg[i].intercept - clipping_arg[j].intercept) / (clipping_arg[j].slope - clipping_arg[i].slope)
                        pt.y = clipping_arg[i].slope * pt.x + clipping_arg[i].intercept
                    end

                    -- オブジェクト外部に交点がある場合を検討する
                    if (pt.y < top) then
                        -- 上側にある場合
                        if (clipping_arg[i].deg < clipping_arg[j].deg) then
                            table.insert(clipping_arg[i].left, j)
                        else
                            table.insert(clipping_arg[i].right, j)
                        end
                    elseif (pt.y > bottom) then
                        -- 下側にある場合
                        if (clipping_arg[i].deg < clipping_arg[j].deg) then
                            table.insert(clipping_arg[i].right, j)
                        else
                            table.insert(clipping_arg[i].left, j)
                        end
                    elseif (pt.x < left) then
                        -- 左側にある場合
                        if (math.max(clipping_arg[i].deg, clipping_arg[j].deg) < 90) then
                            -- 上側と同じ挙動
                            if (clipping_arg[i].deg < clipping_arg[j].deg) then
                                table.insert(clipping_arg[i].left, j)
                            else
                                table.insert(clipping_arg[i].right, j)
                            end
                        elseif (math.min(clipping_arg[i].deg, clipping_arg[j].deg) > 90) then
                            -- 下側と同じ挙動
                            if (clipping_arg[i].deg < clipping_arg[j].deg) then
                                table.insert(clipping_arg[i].right, j)
                            else
                                table.insert(clipping_arg[i].left, j)
                            end
                        else
                            -- 左側固有の挙動
                            if (clipping_arg[i].deg < clipping_arg[j].deg) then
                                table.insert(clipping_arg[i].outer_top, j)
                            else
                                table.insert(clipping_arg[i].outer_bottom, j)
                            end
                        end
                    elseif (pt.x > right) then
                        -- 右側にある場合
                        if (math.min(clipping_arg[i].deg, clipping_arg[j].deg) > 90) then
                            -- 上側と同じ挙動
                            if (clipping_arg[i].deg < clipping_arg[j].deg) then
                                table.insert(clipping_arg[i].left, j)
                            else
                                table.insert(clipping_arg[i].right, j)
                            end
                        elseif (math.max(clipping_arg[i].deg, clipping_arg[j].deg) < 90) then
                            -- 下側と同じ挙動
                            if (clipping_arg[i].deg < clipping_arg[j].deg) then
                                table.insert(clipping_arg[i].right, j)
                            else
                                table.insert(clipping_arg[i].left, j)
                            end
                        else
                            if (clipping_arg[i].deg < clipping_arg[j].deg) then
                                table.insert(clipping_arg[i].inner_bottom, j)
                            else
                                table.insert(clipping_arg[i].inner_top, j)
                            end
                        end
                    end
                end
            end
        end
    end

    -- 描画
    for i = 0, l - 1 do
        local continue = 1
        local reverse = {}
        local clip = {}

        -- 変数の初期化
        for j = 1, separate do
            reverse[j] = (((i % (2 ^ j)) >= (2 ^ (j - 1))) and 1 or 0)
            clip[j] = 1
        end

        for j = 1, separate do
            if (continue == 1 and clip[j]) then
                if (reverse[j] == 0) then
                    -- 反転しない場合
                    for idx, lefter in pairs(clipping_arg[j].left) do
                        -- 左側に別の境界がある場合
                        if (reverse[lefter] == 0) then
                            clip[lefter] = 0
                        else
                            continue = 0
                        end
                    end
                    for idx, righter in pairs(clipping_arg[j].right) do
                        -- 右側に別の境界がある場合
                        if (reverse[righter] == 0) then
                            clip[j] = 0
                        end
                    end
                    for idx, inner_top in pairs(clipping_arg[j].inner_top) do
                        -- 内部方向の上側に別の境界がある場合
                        if (reverse[inner_top] == 0) then
                            continue = 0
                        else
                            clip[inner_top] = 0
                        end
                    end
                    for idx, inner_bottom in pairs(clipping_arg[j].inner_bottom) do
                        -- 内部方向の下側に別の境界がある場合
                        if (reverse[inner_bottom] == 0) then
                            continue = 0
                        else
                            clip[inner_bottom] = 0
                        end
                    end
                    for idx, outer_top in pairs(clipping_arg[j].outer_top) do
                        -- 外部方向の上側に別の境界がある場合
                        if (reverse[outer_top] == 1) then
                            clip[j] = 0
                        end
                    end
                    for idx, outer_bottom in pairs(clipping_arg[j].outer_bottom) do
                        -- 外部方向の下側に別の境界がある場合
                        if (reverse[outer_bottom] == 1) then
                            clip[j] = 0
                        end
                    end
                else
                    -- 反転する場合
                    for idx, lefter in pairs(clipping_arg[j].left) do
                        -- 左側に別の境界が存在する場合
                        if (reverse[lefter] == 1) then
                            clip[j] = 0
                        end
                    end
                    for idx, righter in pairs(clipping_arg[j].right) do
                        -- 右側に別の境界がある場合
                        if (reverse[righter] == 0) then
                            continue = 0
                        else
                            clip[righter] = 0
                        end
                    end
                    for idx, inner_top in pairs(clipping_arg[j].inner_top) do
                        -- 内部方向の上側に別の境界がある場合
                        if (reverse[inner_top] == 0) then
                            clip[j] = 0
                        end
                    end
                    for idx, inner_bottom in pairs(clipping_arg[j].inner_bottom) do
                        -- 内部方向の下側に別の境界がある場合
                        if (reverse[inner_bottom] == 0) then
                            clip[j] = 0
                        end
                    end
                    for idx, outer_top in pairs(clipping_arg[j].outer_top) do
                        -- 外部方向の上側に別の境界がある場合
                        if (reverse[outer_top] == 0) then
                            clip[outer_top] = 0
                        else
                            continue = 0
                        end
                    end
                    for idx, outer_bottom in pairs(clipping_arg[j].outer_bottom) do
                        -- 外部方向の下側に別の境界がある場合
                        if (reverse[outer_bottom] == 0) then
                            clip[outer_bottom] = 0
                        else
                            continue = 0
                        end
                    end
                end
            end
        end

        if (continue == 1) then
            obj.load("tempbuffer")

            -- 斜めクリッピング
            for j = 1, separate do
                if (clip[j] == 1) then
                    local cx = clipping_arg[j].cx
                    local cy = clipping_arg[j].cy
                    local deg = clipping_arg[j].deg
                    if (reverse[j] == 1) then
                        deg = deg + 180
                    end
                    cx = cx - math.sin(math.pi * deg / 180) * surplus
                    cy = cy + math.cos(math.pi * deg / 180) * surplus
                    obj.effect(
                        "斜めクリッピング",
                        "中心X", cx,
                        "中心Y", cy,
                        "角度", deg,
                        "ぼかし", 0)
                end
            end

            obj.ox = src.ox
            obj.oy = src.oy
            obj.oz = src.oz
            obj.cx = src.cx
            obj.cy = src.cy
            obj.cz = src.cz
            obj.rx = src.rx
            obj.ry = src.ry
            obj.rz = src.rz
            obj.alpha = src.alpha
            obj.zoom = src.zoom
            obj.effect()

            local mov_deg = obj.rand(1, 360, i, seed * 10 + 4)
            local x = length * math.cos(math.pi * mov_deg / 180) * r_x + v_x
            local y = length * math.sin(math.pi * mov_deg / 180) * r_y + v_y
            obj.draw(x, y)
        end
    end
end


@揺れ文字（領域指定）
--track0:間隔(ms),0,5000,10,0.01
--track1:拡散距離,0,30,3,0.01
--track2:開始文字数,0,1000,0,1
--track3:終了文字数,0,1000,2,1
--check0:効果適用範囲を可視化,0
--dialog:X方向偏り（px）,v_x=0;Y方向偏り（px）,v_y=0;X軸拡散倍率,r_x=1.0;Y軸拡散倍率,r_y=1.0;分割数,separate=4;余剰部分,surplus=5;

local seed = math.abs(obj.time / (obj.track0 / 1000))
local length = obj.track1
local begin_i = math.min(obj.track2, obj.track3)
local end_i = math.max(obj.track2, obj.track3)
local debugging = obj.check0
seed = math.abs(math.floor(seed))
separate = math.min(math.max(1, math.floor(separate)),16)
r_x = math.max(0, r_x)
r_y = math.max(0, r_y)
local left = -obj.w / 2
local right = obj.w / 2
local top = -obj.h / 2
local bottom = obj.h / 2
local l = 2 ^ separate
local src = {
    ox = obj.ox,
    oy = obj.oy,
    oz = obj.oz,
    cx = obj.cx,
    cy = obj.cy,
    cz = obj.cz,
    rx = obj.rx,
    ry = obj.ry,
    rz = obj.rz,
    alpha = obj.alpha,
    zoom = obj.zoom
}
local clipping_arg = {}

if (progress ~= 0 and src.alpha ~= 0 and src.zoom ~= 0 and (obj.index + 1) >= begin_i and (obj.index + 1) <= end_i) then
    
    if (debugging == false) then

        -- 一時バッファへコピー
        obj.copybuffer("tmp", "obj")
        
        -- 値の初期化
        for i = 1, separate do

            -- 乱数生成
            local cx = obj.rand(left, right, i, seed * 10 + 1)
            local cy = obj.rand(top, bottom, i, seed * 10 + 2)
            local deg = math.floor(obj.rand(1, 180, i, seed * 10 + 3))
            
            -- 生成結果を基に関数情報を設定
            local add_i = #clipping_arg + 1
            local slope = 0
            local intercept = 0
            local non_disp = 0
            local continue = 1

            if (deg ~= 90) then
                slope = math.tan(math.pi * deg / 180)
                intercept = cy - (slope * cx)
            end

            if (add_i ~= 1) then
                for j = 1, add_i - 1 do
                    if ((deg ~= 90 and clipping_arg[j].slope == slope and clipping_arg[j].intercept == intercept) or 
                        (deg == 90 and clipping_arg[j].cx == cx)) then
                        continue = 0
                    end
                end
            end

            if (continue == 1) then
                    
                -- 境界がオブジェクト内部を通過しない可能性を検証
                if (slope > 90) then
                    if (slope * (left + cx) + cy < top) then
                        non_disp = -1
                    elseif (slope * (right + cx) + cy > bottom) then
                        non_disp = 1
                    end
                elseif (slope < 90) then
                    if (slope * (right + cx) + cy < top) then
                        non_disp = 1
                    elseif (slope * (left + cx) + cy > bottom) then
                        non_disp = -1
                    end
                else
                    if (cx < left) then
                        non_disp = -1
                    elseif (cx > right) then
                        non_disp = 1
                    end
                end

                -- 値を格納
                clipping_arg[add_i] = {}
                clipping_arg[add_i].cx = cx
                clipping_arg[add_i].cy = cy
                clipping_arg[add_i].deg = deg
                clipping_arg[add_i].slope = slope
                clipping_arg[add_i].intercept = intercept
                clipping_arg[add_i].non_disp = non_disp
                clipping_arg[add_i].left = {}
                clipping_arg[add_i].right = {}
                clipping_arg[add_i].inner_top = {}
                clipping_arg[add_i].inner_bottom = {}
                clipping_arg[add_i].outer_top = {}
                clipping_arg[add_i].outer_bottom = {}
            end
        end

        separate = #clipping_arg    
        l = 2 ^ separate

        -- 値の位置関係を検討
        for i = 1, separate do
            for j = i, separate do
                if (i ~= j) then
                    -- 二本の境界が平行かどうかを検証する
                    if (clipping_arg[i].deg == clipping_arg[j].deg) then
                        -- 平行である場合
                        -- 切片を用いて検討する
                        if (clipping_arg[i].deg == 90) then
                            if (clipping_arg[i].cx < clipping_arg[j].cx) then
                                table.insert(clipping_arg[i].right, j)
                            else
                                table.insert(clipping_arg[i].left, j)
                            end
                        elseif (clipping_arg[i].intercept > clipping_arg[j].intercept) then
                            table.insert(clipping_arg[i].right, j)
                        else
                            table.insert(clipping_arg[i].left, j)
                        end
                    else
                        -- 平行ではない場合
                        -- 交点を求めて検討する
                        local pt = {}
                        if (clipping_arg[i].deg == 90) then
                            pt.x = clipping_arg[i].cx
                            pt.y = clipping_arg[j].slope * pt.x + clipping_arg[j].intercept
                        elseif (clipping_arg[j].deg == 90) then
                            pt.x = clipping_arg[j].cx
                            pt.y = clipping_arg[i].slope * pt.x + clipping_arg[i].intercept
                        else
                            pt.x = (clipping_arg[i].intercept - clipping_arg[j].intercept) / (clipping_arg[j].slope - clipping_arg[i].slope)
                            pt.y = clipping_arg[i].slope * pt.x + clipping_arg[i].intercept
                        end

                        -- オブジェクト外部に交点がある場合を検討する
                        if (pt.y < top) then
                            -- 上側にある場合
                            if (clipping_arg[i].deg < clipping_arg[j].deg) then
                                table.insert(clipping_arg[i].left, j)
                            else
                                table.insert(clipping_arg[i].right, j)
                            end
                        elseif (pt.y > bottom) then
                            -- 下側にある場合
                            if (clipping_arg[i].deg < clipping_arg[j].deg) then
                                table.insert(clipping_arg[i].right, j)
                            else
                                table.insert(clipping_arg[i].left, j)
                            end
                        elseif (pt.x < left) then
                            -- 左側にある場合
                            if (math.max(clipping_arg[i].deg, clipping_arg[j].deg) < 90) then
                                -- 上側と同じ挙動
                                if (clipping_arg[i].deg < clipping_arg[j].deg) then
                                    table.insert(clipping_arg[i].left, j)
                                else
                                    table.insert(clipping_arg[i].right, j)
                                end
                            elseif (math.min(clipping_arg[i].deg, clipping_arg[j].deg) > 90) then
                                -- 下側と同じ挙動
                                if (clipping_arg[i].deg < clipping_arg[j].deg) then
                                    table.insert(clipping_arg[i].right, j)
                                else
                                    table.insert(clipping_arg[i].left, j)
                                end
                            else
                                -- 左側固有の挙動
                                if (clipping_arg[i].deg < clipping_arg[j].deg) then
                                    table.insert(clipping_arg[i].outer_top, j)
                                else
                                    table.insert(clipping_arg[i].outer_bottom, j)
                                end
                            end
                        elseif (pt.x > right) then
                            -- 右側にある場合
                            if (math.min(clipping_arg[i].deg, clipping_arg[j].deg) > 90) then
                                -- 上側と同じ挙動
                                if (clipping_arg[i].deg < clipping_arg[j].deg) then
                                    table.insert(clipping_arg[i].left, j)
                                else
                                    table.insert(clipping_arg[i].right, j)
                                end
                            elseif (math.max(clipping_arg[i].deg, clipping_arg[j].deg) < 90) then
                                -- 下側と同じ挙動
                                if (clipping_arg[i].deg < clipping_arg[j].deg) then
                                    table.insert(clipping_arg[i].right, j)
                                else
                                    table.insert(clipping_arg[i].left, j)
                                end
                            else
                                if (clipping_arg[i].deg < clipping_arg[j].deg) then
                                    table.insert(clipping_arg[i].inner_bottom, j)
                                else
                                    table.insert(clipping_arg[i].inner_top, j)
                                end
                            end
                        end
                    end
                end
            end
        end

        -- 描画
        for i = 0, l - 1 do
            local continue = 1
            local reverse = {}
            local clip = {}

            -- 変数の初期化
            for j = 1, separate do
                reverse[j] = (((i % (2 ^ j)) >= (2 ^ (j - 1))) and 1 or 0)
                clip[j] = 1
            end

            for j = 1, separate do
                if (continue == 1 and clip[j]) then
                    if (reverse[j] == 0) then
                        -- 反転しない場合
                        for idx, lefter in pairs(clipping_arg[j].left) do
                            -- 左側に別の境界がある場合
                            if (reverse[lefter] == 0) then
                                clip[lefter] = 0
                            else
                                continue = 0
                            end
                        end
                        for idx, righter in pairs(clipping_arg[j].right) do
                            -- 右側に別の境界がある場合
                            if (reverse[righter] == 0) then
                                clip[j] = 0
                            end
                        end
                        for idx, inner_top in pairs(clipping_arg[j].inner_top) do
                            -- 内部方向の上側に別の境界がある場合
                            if (reverse[inner_top] == 0) then
                                continue = 0
                            else
                                clip[inner_top] = 0
                            end
                        end
                        for idx, inner_bottom in pairs(clipping_arg[j].inner_bottom) do
                            -- 内部方向の下側に別の境界がある場合
                            if (reverse[inner_bottom] == 0) then
                                continue = 0
                            else
                                clip[inner_bottom] = 0
                            end
                        end
                        for idx, outer_top in pairs(clipping_arg[j].outer_top) do
                            -- 外部方向の上側に別の境界がある場合
                            if (reverse[outer_top] == 1) then
                                clip[j] = 0
                            end
                        end
                        for idx, outer_bottom in pairs(clipping_arg[j].outer_bottom) do
                            -- 外部方向の下側に別の境界がある場合
                            if (reverse[outer_bottom] == 1) then
                                clip[j] = 0
                            end
                        end
                    else
                        -- 反転する場合
                        for idx, lefter in pairs(clipping_arg[j].left) do
                            -- 左側に別の境界が存在する場合
                            if (reverse[lefter] == 1) then
                                clip[j] = 0
                            end
                        end
                        for idx, righter in pairs(clipping_arg[j].right) do
                            -- 右側に別の境界がある場合
                            if (reverse[righter] == 0) then
                                continue = 0
                            else
                                clip[righter] = 0
                            end
                        end
                        for idx, inner_top in pairs(clipping_arg[j].inner_top) do
                            -- 内部方向の上側に別の境界がある場合
                            if (reverse[inner_top] == 0) then
                                clip[j] = 0
                            end
                        end
                        for idx, inner_bottom in pairs(clipping_arg[j].inner_bottom) do
                            -- 内部方向の下側に別の境界がある場合
                            if (reverse[inner_bottom] == 0) then
                                clip[j] = 0
                            end
                        end
                        for idx, outer_top in pairs(clipping_arg[j].outer_top) do
                            -- 外部方向の上側に別の境界がある場合
                            if (reverse[outer_top] == 0) then
                                clip[outer_top] = 0
                            else
                                continue = 0
                            end
                        end
                        for idx, outer_bottom in pairs(clipping_arg[j].outer_bottom) do
                            -- 外部方向の下側に別の境界がある場合
                            if (reverse[outer_bottom] == 0) then
                                clip[outer_bottom] = 0
                            else
                                continue = 0
                            end
                        end
                    end
                end
            end

            if (continue == 1) then
                obj.load("tempbuffer")

                -- 斜めクリッピング
                for j = 1, separate do
                    if (clip[j] == 1) then
                        local cx = clipping_arg[j].cx
                        local cy = clipping_arg[j].cy
                        local deg = clipping_arg[j].deg
                        if (reverse[j] == 1) then
                            deg = deg + 180
                        end
                        cx = cx - math.sin(math.pi * deg / 180) * surplus
                        cy = cy + math.cos(math.pi * deg / 180) * surplus
                        obj.effect(
                            "斜めクリッピング",
                            "中心X", cx,
                            "中心Y", cy,
                            "角度", deg,
                            "ぼかし", 0)
                    end
                end

                obj.ox = src.ox
                obj.oy = src.oy
                obj.oz = src.oz
                obj.cx = src.cx
                obj.cy = src.cy
                obj.cz = src.cz
                obj.rx = src.rx
                obj.ry = src.ry
                obj.rz = src.rz
                obj.alpha = src.alpha
                obj.zoom = src.zoom
                obj.effect()

                local mov_deg = obj.rand(1, 360, i, seed * 10 + 4)
                local x = length * math.cos(math.pi * mov_deg / 180) * r_x + v_x
                local y = length * math.sin(math.pi * mov_deg / 180) * r_y + v_y
                obj.draw(x, y)
            end
        end
    else
        obj.effect("単色化", "強さ", 80, "輝度を保持する", 0, "color", 0x00ff00)
    end
end

